<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ToneDesigner Code Tester</title>
    <script src="https://unpkg.com/tone@latest/build/Tone.js"></script>
    <style>
        body {
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 20px;
            background: #000;
            color: #fff;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #fff;
            font-size: 2em;
            margin-bottom: 30px;
            letter-spacing: 2px;
        }
        
        .instructions {
            background: #111;
            padding: 20px;
            border: 1px solid #333;
            margin-bottom: 20px;
            border-radius: 4px;
        }
        
        .code-area {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .code-input {
            flex: 1;
        }
        
        .code-output {
            flex: 1;
        }
        
        textarea {
            width: 100%;
            height: 400px;
            background: #111;
            color: #0f0;
            border: 1px solid #333;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
            border-radius: 4px;
        }
        
        textarea:focus {
            outline: none;
            border-color: #0f0;
        }
        
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        
        button {
            background: #222;
            color: #fff;
            border: 1px solid #555;
            padding: 12px 24px;
            margin: 0 10px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #333;
            border-color: #777;
        }
        
        button:disabled {
            background: #111;
            color: #555;
            cursor: not-allowed;
        }
        
        .play-btn {
            background: #0a5d0a;
            border-color: #0f0;
        }
        
        .play-btn:hover:not(:disabled) {
            background: #0f5d0f;
        }
        
        .stop-btn {
            background: #5d0a0a;
            border-color: #f00;
        }
        
        .stop-btn:hover:not(:disabled) {
            background: #5d0f0f;
        }
        
        .status {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        
        .status.success {
            background: #0a5d0a;
            border: 1px solid #0f0;
        }
        
        .status.error {
            background: #5d0a0a;
            border: 1px solid #f00;
        }
        
        .status.info {
            background: #0a0a5d;
            border: 1px solid #00f;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #ccc;
            font-weight: bold;
        }
        
        .sample-code {
            background: #0a0a0a;
            border: 1px solid #333;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>TONEDESIGNER CODE TESTER</h1>
        
        <div class="instructions">
            <h3>How to Test:</h3>
            <ol>
                <li>Create a patch in ToneDesigner</li>
                <li>Click "CODE" to export the generated code</li>
                <li>Copy the code and paste it into the textarea below</li>
                <li>Click "LOAD CODE" to parse and prepare the code</li>
                <li>Click "PLAY" to test the sound</li>
                <li>Click "STOP" to stop all audio</li>
            </ol>
            <p><strong>Note:</strong> This proves that ToneDesigner's exported code works independently in any Tone.js environment.</p>
        </div>
        
        <div class="code-area">
            <div class="code-input">
                <label for="codeInput">Paste ToneDesigner Code Here:</label>
                <textarea id="codeInput" placeholder="Paste your ToneDesigner generated code here...

Example:
await Tone.start();

// ═══════════════════════════════════════════════════════════════
// INSTANTIATION BLOCK - Module Declarations  
// ═══════════════════════════════════════════════════════════════

const oscillator1 = new Tone.Oscillator({
    type: &quot;sine&quot;,
    frequency: 440,
    detune: 0
}).start();

// ═══════════════════════════════════════════════════════════════
// PATCHING BLOCK - Signal Routing (DYNAMIC)
// ═══════════════════════════════════════════════════════════════

oscillator1.toDestination();"></textarea>
            </div>
            
            <div class="code-output">
                <label for="codeOutput">Processed Code (Auto-Generated):</label>
                <textarea id="codeOutput" readonly placeholder="Processed code will appear here after clicking 'LOAD CODE'..."></textarea>
            </div>
        </div>
        
        <div class="controls">
            <button id="loadBtn">LOAD CODE</button>
            <button id="playBtn" class="play-btn" disabled>PLAY</button>
            <button id="stopBtn" class="stop-btn" disabled>STOP</button>
            <button id="clearBtn">CLEAR</button>
        </div>
        
        <div id="status" class="status" style="display: none;"></div>
        
        <div class="sample-code">
            <strong>Sample ToneDesigner Output:</strong><br>
            This tester accepts any valid ToneDesigner generated code. The code structure includes:
            <ul>
                <li>Instantiation Block: Creates Tone.js objects</li>
                <li>Patching Block: Connects modules together</li>
                <li>Triggering Block: Play functions (optional)</li>
            </ul>
        </div>
    </div>

    <script>
        // Global variables for audio management
        let loadedAudioObjects = {};
        let isPlaying = false;
        let activeConnections = [];

        // DOM elements
        const codeInput = document.getElementById('codeInput');
        const codeOutput = document.getElementById('codeOutput');
        const loadBtn = document.getElementById('loadBtn');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const clearBtn = document.getElementById('clearBtn');
        const status = document.getElementById('status');

        // Status display function
        function showStatus(message, type = 'info') {
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            
            if (type !== 'error') {
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            }
        }

        // Load and parse the pasted code
        async function loadCode() {
            const code = codeInput.value.trim();
            
            if (!code) {
                showStatus('Please paste some ToneDesigner code first', 'error');
                return;
            }

            try {
                // Stop any existing audio first
                await stopAudio();
                
                // Clear previous objects
                loadedAudioObjects = {};
                
                // Show the EXACT code that will be executed (no processing)
                codeOutput.value = code;
                
                console.log('ToneDesigner code (UNMODIFIED):', code);
                
                showStatus('Code loaded! This is the EXACT ToneDesigner export. Click PLAY to test.', 'success');
                playBtn.disabled = false;
                stopBtn.disabled = false;
                
            } catch (error) {
                showStatus(`Error loading code: ${error.message}`, 'error');
                console.error('Code loading error:', error);
            }
        }

        // Simple, safe code processor - minimal changes to preserve ToneDesigner output
        function processCodeForExecution(code) {
            // Step 1: Remove await Tone.start() - we handle this separately
            let processed = code.replace(/await\s+Tone\.start\(\);\s*\n*/g, '');
            
            // Step 2: Simple const to window replacement - preserve everything else
            processed = processed.replace(/^const (\w+) = /gm, 'window.$1 = ');
            
            // Step 3: Fix connection calls to use window prefix
            const lines = processed.split('\n');
            const definedVars = new Set();
            
            // Collect defined variables
            lines.forEach(line => {
                const match = line.match(/window\.(\w+)\s*=/);
                if (match) definedVars.add(match[1]);
            });
            
            // Process each line
            const validLines = lines.map(line => {
                const trimmed = line.trim();
                
                // Skip lines that reference undefined variables
                if (trimmed.includes('eq81')) {
                    return `// SKIPPED: ${trimmed} (eq81 not defined)`;
                }
                
                // Fix connection calls - add window prefix to variable references
                if (trimmed.includes('.connect(') || trimmed.includes('.toDestination(')) {
                    let fixed = line;
                    
                    // Fix all variable references in the line
                    for (const varName of definedVars) {
                        // Match bare variable references (not already prefixed with window.)
                        const regex = new RegExp(`(?<!window\\.)\\b${varName}\\b`, 'g');
                        fixed = fixed.replace(regex, `window.${varName}`);
                    }
                    
                    return fixed;
                }
                
                // Fix function calls that reference variables
                if (trimmed.includes('oscillator1') || trimmed.includes('envelope1')) {
                    let fixed = line;
                    for (const varName of definedVars) {
                        if (line.includes(varName) && !line.includes(`window.${varName}`)) {
                            const regex = new RegExp(`\\b${varName}\\b(?=\\.)`, 'g');
                            fixed = fixed.replace(regex, `window.${varName}`);
                        }
                    }
                    return fixed;
                }
                
                return line;
            });
            
            let result = validLines.join('\n');
            
            // Step 4: Add missing connection and auto-trigger
            if (result.includes('SKIPPED') && result.includes('reverb1') && result.includes('mixer1')) {
                result += '\nwindow.reverb1.connect(window.mixer1); // Fixed broken chain';
            }
            
            if (result.includes('playSynth')) {
                result += '\n\n// Auto-trigger\nsetTimeout(() => window.playSynth("C4", "2n"), 500);';
            }
            
            return result;
        }

        // Execute the EXACT ToneDesigner code in a proper module context
        async function executeCode() {
            try {
                const code = codeOutput.value;
                if (!code) {
                    showStatus('No code to execute. Load code first.', 'error');
                    return;
                }

                // Clear previous objects
                loadedAudioObjects = {};
                
                // Start Tone.js
                await Tone.start();
                
                console.log('Executing EXACT ToneDesigner code (no modifications)');
                
                // Create a module-like context by wrapping in an immediately invoked function
                // This creates proper local scope like a real project would have
                const moduleCode = `
                    (async function ToneDesignerPatch() {
                        ${code}
                        
                        // Return all local variables for testing
                        const variables = {};
                        ${generateVariableCapture(code)}
                        return variables;
                    })();
                `;
                
                // Execute and capture the result
                const patchVariables = await eval(moduleCode);
                loadedAudioObjects = patchVariables;
                
                console.log('Patch loaded with variables:', Object.keys(loadedAudioObjects));
                
                // Debug audio connections
                console.log('=== AUDIO DEBUG ===');
                Object.entries(loadedAudioObjects).forEach(([name, obj]) => {
                    if (obj && obj.context) {
                        console.log(`${name}:`, {
                            type: obj.constructor.name,
                            state: obj.state || 'unknown',
                            connected: obj._destinations?.length || 0,
                            destinations: obj._destinations || []
                        });
                    }
                });
                
                // Test manual connection to verify it works
                console.log('Testing manual connection...');
                if (loadedAudioObjects.oscillator1 && loadedAudioObjects.filter1) {
                    loadedAudioObjects.oscillator1.connect(loadedAudioObjects.filter1);
                    console.log('Manual connection made - oscillator1 → filter1');
                    console.log('Oscillator1 now connected to:', loadedAudioObjects.oscillator1._destinations?.length || 0);
                }
                console.log('===================');
                
                showStatus('EXACT ToneDesigner code executed successfully!', 'success');
                
                // Auto-trigger for testing (envelope needs to be triggered)
                if (loadedAudioObjects.playSynth) {
                    setTimeout(() => {
                        console.log('Auto-triggering playSynth...');
                        loadedAudioObjects.playSynth("C4", "2n");
                    }, 500);
                }
                
            } catch (error) {
                showStatus(`Execution error: ${error.message}`, 'error');
                console.error('Execution error:', error);
                console.error('ToneDesigner code that failed:');
                console.error(codeOutput.value);
                return;
            }
        }
        
        // Generate code to capture local variables from the ToneDesigner patch
        function generateVariableCapture(code) {
            const variables = [];
            const constMatches = code.matchAll(/const\s+(\w+)\s*=/g);
            for (const match of constMatches) {
                variables.push(match[1]);
            }
            
            return variables.map(varName => 
                `if (typeof ${varName} !== 'undefined') variables.${varName} = ${varName};`
            ).join('\n');
        }

        // Play the audio
        async function playAudio() {
            try {
                await Tone.start();
                await executeCode();
                
                isPlaying = true;
                playBtn.disabled = true;
                
                showStatus('Audio playing...', 'success');
                
            } catch (error) {
                showStatus(`Play error: ${error.message}`, 'error');
                isPlaying = false;
                playBtn.disabled = false;
            }
        }

        // Stop all audio
        async function stopAudio() {
            try {
                // Stop all window-based Tone objects
                const windowVars = Object.getOwnPropertyNames(window);
                windowVars.forEach(varName => {
                    const obj = window[varName];
                    if (obj && typeof obj === 'object') {
                        try {
                            // Stop oscillators and sources
                            if (typeof obj.stop === 'function') {
                                obj.stop();
                            }
                            // Dispose all Tone objects
                            if (typeof obj.dispose === 'function') {
                                obj.dispose();
                                delete window[varName];
                            }
                        } catch (e) {
                            console.warn(`Error stopping/disposing ${varName}:`, e);
                        }
                    }
                });
                
                // Stop and dispose all loaded objects
                Object.values(loadedAudioObjects).forEach(obj => {
                    try {
                        if (obj && typeof obj.stop === 'function') {
                            obj.stop();
                        }
                        if (obj && typeof obj.dispose === 'function') {
                            obj.dispose();
                        }
                    } catch (e) {
                        console.warn('Error stopping/disposing object:', e);
                    }
                });
                
                // Clear the registry
                loadedAudioObjects = {};
                
                // Stop Tone.js transport
                Tone.Transport.stop();
                Tone.Transport.cancel();
                
                // Stop all audio context
                if (Tone.context.state === 'running') {
                    await Tone.context.suspend();
                    await Tone.context.resume();
                }
                
                isPlaying = false;
                playBtn.disabled = false;
                
                showStatus('Audio stopped and cleaned up', 'info');
                
            } catch (error) {
                showStatus(`Stop error: ${error.message}`, 'error');
                console.error('Stop error:', error);
            }
        }

        // Clear everything
        function clearAll() {
            stopAudio();
            codeInput.value = '';
            codeOutput.value = '';
            playBtn.disabled = true;
            stopBtn.disabled = true;
            status.style.display = 'none';
        }

        // Event listeners
        loadBtn.addEventListener('click', loadCode);
        playBtn.addEventListener('click', playAudio);
        stopBtn.addEventListener('click', stopAudio);
        clearBtn.addEventListener('click', clearAll);

        // Test function to verify basic functionality
        function runBasicTest() {
            const testCode = `window.testOsc = new Tone.Oscillator({
    type: "sine",
    frequency: 440
});
window.testOsc.start();
window.testOsc.toDestination();`;
            
            try {
                eval(testCode);
                console.log('Basic test passed');
                return true;
            } catch (error) {
                console.error('Basic test failed:', error);
                return false;
            }
        }

        // Initialize
        showStatus('Ready to test ToneDesigner code. Paste code and click LOAD CODE.', 'info');
        
        // Run basic test on page load
        setTimeout(() => {
            if (runBasicTest()) {
                console.log('Code execution environment is working');
            }
        }, 1000);
    </script>
</body>
</html>